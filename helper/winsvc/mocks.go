// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package winsvc

import (
	mock "github.com/stretchr/testify/mock"
)

// NewMockEventlog creates a new instance of MockEventlog. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventlog(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventlog {
	mock := &MockEventlog{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventlog is an autogenerated mock type for the Eventlog type
type MockEventlog struct {
	mock.Mock
}

type MockEventlog_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventlog) EXPECT() *MockEventlog_Expecter {
	return &MockEventlog_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockEventlog
func (_mock *MockEventlog) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventlog_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockEventlog_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockEventlog_Expecter) Close() *MockEventlog_Close_Call {
	return &MockEventlog_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockEventlog_Close_Call) Run(run func()) *MockEventlog_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockEventlog_Close_Call) Return(err error) *MockEventlog_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventlog_Close_Call) RunAndReturn(run func() error) *MockEventlog_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Error provides a mock function for the type MockEventlog
func (_mock *MockEventlog) Error(v uint32, s string) error {
	ret := _mock.Called(v, s)

	if len(ret) == 0 {
		panic("no return value specified for Error")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint32, string) error); ok {
		r0 = returnFunc(v, s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventlog_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type MockEventlog_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
//   - v uint32
//   - s string
func (_e *MockEventlog_Expecter) Error(v interface{}, s interface{}) *MockEventlog_Error_Call {
	return &MockEventlog_Error_Call{Call: _e.mock.On("Error", v, s)}
}

func (_c *MockEventlog_Error_Call) Run(run func(v uint32, s string)) *MockEventlog_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint32
		if args[0] != nil {
			arg0 = args[0].(uint32)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventlog_Error_Call) Return(err error) *MockEventlog_Error_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventlog_Error_Call) RunAndReturn(run func(v uint32, s string) error) *MockEventlog_Error_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function for the type MockEventlog
func (_mock *MockEventlog) Info(v uint32, s string) error {
	ret := _mock.Called(v, s)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint32, string) error); ok {
		r0 = returnFunc(v, s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventlog_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockEventlog_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - v uint32
//   - s string
func (_e *MockEventlog_Expecter) Info(v interface{}, s interface{}) *MockEventlog_Info_Call {
	return &MockEventlog_Info_Call{Call: _e.mock.On("Info", v, s)}
}

func (_c *MockEventlog_Info_Call) Run(run func(v uint32, s string)) *MockEventlog_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint32
		if args[0] != nil {
			arg0 = args[0].(uint32)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventlog_Info_Call) Return(err error) *MockEventlog_Info_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventlog_Info_Call) RunAndReturn(run func(v uint32, s string) error) *MockEventlog_Info_Call {
	_c.Call.Return(run)
	return _c
}

// Warning provides a mock function for the type MockEventlog
func (_mock *MockEventlog) Warning(v uint32, s string) error {
	ret := _mock.Called(v, s)

	if len(ret) == 0 {
		panic("no return value specified for Warning")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(uint32, string) error); ok {
		r0 = returnFunc(v, s)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventlog_Warning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warning'
type MockEventlog_Warning_Call struct {
	*mock.Call
}

// Warning is a helper method to define mock.On call
//   - v uint32
//   - s string
func (_e *MockEventlog_Expecter) Warning(v interface{}, s interface{}) *MockEventlog_Warning_Call {
	return &MockEventlog_Warning_Call{Call: _e.mock.On("Warning", v, s)}
}

func (_c *MockEventlog_Warning_Call) Run(run func(v uint32, s string)) *MockEventlog_Warning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 uint32
		if args[0] != nil {
			arg0 = args[0].(uint32)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventlog_Warning_Call) Return(err error) *MockEventlog_Warning_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventlog_Warning_Call) RunAndReturn(run func(v uint32, s string) error) *MockEventlog_Warning_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWindowsService creates a new instance of MockWindowsService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWindowsService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWindowsService {
	mock := &MockWindowsService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWindowsService is an autogenerated mock type for the WindowsService type
type MockWindowsService struct {
	mock.Mock
}

type MockWindowsService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWindowsService) EXPECT() *MockWindowsService_Expecter {
	return &MockWindowsService_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockWindowsService_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) Close() *MockWindowsService_Close_Call {
	return &MockWindowsService_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockWindowsService_Close_Call) Run(run func()) *MockWindowsService_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_Close_Call) Return(err error) *MockWindowsService_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_Close_Call) RunAndReturn(run func() error) *MockWindowsService_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Configure provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) Configure(config WindowsServiceConfiguration) error {
	ret := _mock.Called(config)

	if len(ret) == 0 {
		panic("no return value specified for Configure")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(WindowsServiceConfiguration) error); ok {
		r0 = returnFunc(config)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_Configure_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Configure'
type MockWindowsService_Configure_Call struct {
	*mock.Call
}

// Configure is a helper method to define mock.On call
//   - config WindowsServiceConfiguration
func (_e *MockWindowsService_Expecter) Configure(config interface{}) *MockWindowsService_Configure_Call {
	return &MockWindowsService_Configure_Call{Call: _e.mock.On("Configure", config)}
}

func (_c *MockWindowsService_Configure_Call) Run(run func(config WindowsServiceConfiguration)) *MockWindowsService_Configure_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 WindowsServiceConfiguration
		if args[0] != nil {
			arg0 = args[0].(WindowsServiceConfiguration)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWindowsService_Configure_Call) Return(err error) *MockWindowsService_Configure_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_Configure_Call) RunAndReturn(run func(config WindowsServiceConfiguration) error) *MockWindowsService_Configure_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) Delete() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockWindowsService_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) Delete() *MockWindowsService_Delete_Call {
	return &MockWindowsService_Delete_Call{Call: _e.mock.On("Delete")}
}

func (_c *MockWindowsService_Delete_Call) Run(run func()) *MockWindowsService_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_Delete_Call) Return(err error) *MockWindowsService_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_Delete_Call) RunAndReturn(run func() error) *MockWindowsService_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DisableEventlog provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) DisableEventlog() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for DisableEventlog")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_DisableEventlog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableEventlog'
type MockWindowsService_DisableEventlog_Call struct {
	*mock.Call
}

// DisableEventlog is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) DisableEventlog() *MockWindowsService_DisableEventlog_Call {
	return &MockWindowsService_DisableEventlog_Call{Call: _e.mock.On("DisableEventlog")}
}

func (_c *MockWindowsService_DisableEventlog_Call) Run(run func()) *MockWindowsService_DisableEventlog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_DisableEventlog_Call) Return(err error) *MockWindowsService_DisableEventlog_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_DisableEventlog_Call) RunAndReturn(run func() error) *MockWindowsService_DisableEventlog_Call {
	_c.Call.Return(run)
	return _c
}

// EnableEventlog provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) EnableEventlog() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for EnableEventlog")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_EnableEventlog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableEventlog'
type MockWindowsService_EnableEventlog_Call struct {
	*mock.Call
}

// EnableEventlog is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) EnableEventlog() *MockWindowsService_EnableEventlog_Call {
	return &MockWindowsService_EnableEventlog_Call{Call: _e.mock.On("EnableEventlog")}
}

func (_c *MockWindowsService_EnableEventlog_Call) Run(run func()) *MockWindowsService_EnableEventlog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_EnableEventlog_Call) Return(err error) *MockWindowsService_EnableEventlog_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_EnableEventlog_Call) RunAndReturn(run func() error) *MockWindowsService_EnableEventlog_Call {
	_c.Call.Return(run)
	return _c
}

// IsRunning provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) IsRunning() (bool, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRunning")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (bool, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWindowsService_IsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRunning'
type MockWindowsService_IsRunning_Call struct {
	*mock.Call
}

// IsRunning is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) IsRunning() *MockWindowsService_IsRunning_Call {
	return &MockWindowsService_IsRunning_Call{Call: _e.mock.On("IsRunning")}
}

func (_c *MockWindowsService_IsRunning_Call) Run(run func()) *MockWindowsService_IsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_IsRunning_Call) Return(b bool, err error) *MockWindowsService_IsRunning_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockWindowsService_IsRunning_Call) RunAndReturn(run func() (bool, error)) *MockWindowsService_IsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// IsStopped provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) IsStopped() (bool, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsStopped")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (bool, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWindowsService_IsStopped_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsStopped'
type MockWindowsService_IsStopped_Call struct {
	*mock.Call
}

// IsStopped is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) IsStopped() *MockWindowsService_IsStopped_Call {
	return &MockWindowsService_IsStopped_Call{Call: _e.mock.On("IsStopped")}
}

func (_c *MockWindowsService_IsStopped_Call) Run(run func()) *MockWindowsService_IsStopped_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_IsStopped_Call) Return(b bool, err error) *MockWindowsService_IsStopped_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockWindowsService_IsStopped_Call) RunAndReturn(run func() (bool, error)) *MockWindowsService_IsStopped_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockWindowsService_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockWindowsService_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) Name() *MockWindowsService_Name_Call {
	return &MockWindowsService_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockWindowsService_Name_Call) Run(run func()) *MockWindowsService_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_Name_Call) Return(s string) *MockWindowsService_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockWindowsService_Name_Call) RunAndReturn(run func() string) *MockWindowsService_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) Start() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockWindowsService_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) Start() *MockWindowsService_Start_Call {
	return &MockWindowsService_Start_Call{Call: _e.mock.On("Start")}
}

func (_c *MockWindowsService_Start_Call) Run(run func()) *MockWindowsService_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_Start_Call) Return(err error) *MockWindowsService_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_Start_Call) RunAndReturn(run func() error) *MockWindowsService_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function for the type MockWindowsService
func (_mock *MockWindowsService) Stop() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsService_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockWindowsService_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *MockWindowsService_Expecter) Stop() *MockWindowsService_Stop_Call {
	return &MockWindowsService_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *MockWindowsService_Stop_Call) Run(run func()) *MockWindowsService_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsService_Stop_Call) Return(err error) *MockWindowsService_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsService_Stop_Call) RunAndReturn(run func() error) *MockWindowsService_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWindowsServiceManager creates a new instance of MockWindowsServiceManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWindowsServiceManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWindowsServiceManager {
	mock := &MockWindowsServiceManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWindowsServiceManager is an autogenerated mock type for the WindowsServiceManager type
type MockWindowsServiceManager struct {
	mock.Mock
}

type MockWindowsServiceManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWindowsServiceManager) EXPECT() *MockWindowsServiceManager_Expecter {
	return &MockWindowsServiceManager_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockWindowsServiceManager
func (_mock *MockWindowsServiceManager) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWindowsServiceManager_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockWindowsServiceManager_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockWindowsServiceManager_Expecter) Close() *MockWindowsServiceManager_Close_Call {
	return &MockWindowsServiceManager_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockWindowsServiceManager_Close_Call) Run(run func()) *MockWindowsServiceManager_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWindowsServiceManager_Close_Call) Return(err error) *MockWindowsServiceManager_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWindowsServiceManager_Close_Call) RunAndReturn(run func() error) *MockWindowsServiceManager_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CreateService provides a mock function for the type MockWindowsServiceManager
func (_mock *MockWindowsServiceManager) CreateService(name string, binaryPath string, config WindowsServiceConfiguration) (WindowsService, error) {
	ret := _mock.Called(name, binaryPath, config)

	if len(ret) == 0 {
		panic("no return value specified for CreateService")
	}

	var r0 WindowsService
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, WindowsServiceConfiguration) (WindowsService, error)); ok {
		return returnFunc(name, binaryPath, config)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, WindowsServiceConfiguration) WindowsService); ok {
		r0 = returnFunc(name, binaryPath, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(WindowsService)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, WindowsServiceConfiguration) error); ok {
		r1 = returnFunc(name, binaryPath, config)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWindowsServiceManager_CreateService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateService'
type MockWindowsServiceManager_CreateService_Call struct {
	*mock.Call
}

// CreateService is a helper method to define mock.On call
//   - name string
//   - binaryPath string
//   - config WindowsServiceConfiguration
func (_e *MockWindowsServiceManager_Expecter) CreateService(name interface{}, binaryPath interface{}, config interface{}) *MockWindowsServiceManager_CreateService_Call {
	return &MockWindowsServiceManager_CreateService_Call{Call: _e.mock.On("CreateService", name, binaryPath, config)}
}

func (_c *MockWindowsServiceManager_CreateService_Call) Run(run func(name string, binaryPath string, config WindowsServiceConfiguration)) *MockWindowsServiceManager_CreateService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 WindowsServiceConfiguration
		if args[2] != nil {
			arg2 = args[2].(WindowsServiceConfiguration)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockWindowsServiceManager_CreateService_Call) Return(windowsService WindowsService, err error) *MockWindowsServiceManager_CreateService_Call {
	_c.Call.Return(windowsService, err)
	return _c
}

func (_c *MockWindowsServiceManager_CreateService_Call) RunAndReturn(run func(name string, binaryPath string, config WindowsServiceConfiguration) (WindowsService, error)) *MockWindowsServiceManager_CreateService_Call {
	_c.Call.Return(run)
	return _c
}

// GetService provides a mock function for the type MockWindowsServiceManager
func (_mock *MockWindowsServiceManager) GetService(name string) (WindowsService, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for GetService")
	}

	var r0 WindowsService
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (WindowsService, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) WindowsService); ok {
		r0 = returnFunc(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(WindowsService)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWindowsServiceManager_GetService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetService'
type MockWindowsServiceManager_GetService_Call struct {
	*mock.Call
}

// GetService is a helper method to define mock.On call
//   - name string
func (_e *MockWindowsServiceManager_Expecter) GetService(name interface{}) *MockWindowsServiceManager_GetService_Call {
	return &MockWindowsServiceManager_GetService_Call{Call: _e.mock.On("GetService", name)}
}

func (_c *MockWindowsServiceManager_GetService_Call) Run(run func(name string)) *MockWindowsServiceManager_GetService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWindowsServiceManager_GetService_Call) Return(windowsService WindowsService, err error) *MockWindowsServiceManager_GetService_Call {
	_c.Call.Return(windowsService, err)
	return _c
}

func (_c *MockWindowsServiceManager_GetService_Call) RunAndReturn(run func(name string) (WindowsService, error)) *MockWindowsServiceManager_GetService_Call {
	_c.Call.Return(run)
	return _c
}

// IsServiceRegistered provides a mock function for the type MockWindowsServiceManager
func (_mock *MockWindowsServiceManager) IsServiceRegistered(name string) (bool, error) {
	ret := _mock.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for IsServiceRegistered")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return returnFunc(name)
	}
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(name)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWindowsServiceManager_IsServiceRegistered_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsServiceRegistered'
type MockWindowsServiceManager_IsServiceRegistered_Call struct {
	*mock.Call
}

// IsServiceRegistered is a helper method to define mock.On call
//   - name string
func (_e *MockWindowsServiceManager_Expecter) IsServiceRegistered(name interface{}) *MockWindowsServiceManager_IsServiceRegistered_Call {
	return &MockWindowsServiceManager_IsServiceRegistered_Call{Call: _e.mock.On("IsServiceRegistered", name)}
}

func (_c *MockWindowsServiceManager_IsServiceRegistered_Call) Run(run func(name string)) *MockWindowsServiceManager_IsServiceRegistered_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockWindowsServiceManager_IsServiceRegistered_Call) Return(b bool, err error) *MockWindowsServiceManager_IsServiceRegistered_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockWindowsServiceManager_IsServiceRegistered_Call) RunAndReturn(run func(name string) (bool, error)) *MockWindowsServiceManager_IsServiceRegistered_Call {
	_c.Call.Return(run)
	return _c
}
