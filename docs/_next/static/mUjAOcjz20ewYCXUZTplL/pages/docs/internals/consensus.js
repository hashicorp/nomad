(window.webpackJsonp=window.webpackJsonp||[]).push([[211],{URTX:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/internals/consensus",function(){return a("hILh")}])},hILh:function(e,t,a){"use strict";a.r(t),a.d(t,"default",(function(){return d}));var n=a("wx14"),s=a("Ff2n"),o=a("q1tI"),r=a.n(o),i=a("7ljp"),l=a("j1un"),c=(r.a.createElement,{}),b=Object(l.a)({layout:"docs",page_title:"Consensus Protocol",sidebar_title:"Consensus Protocol",description:"Nomad uses a consensus protocol to provide Consistency as defined by CAP.\nThe consensus protocol is based on Raft: In search of an Understandable\nConsensus Algorithm. For a visual explanation of Raft, see The Secret Lives of\nData.",__resourcePath:"docs/internals/consensus.mdx",__scans:{}});function d(e){var t=e.components,a=Object(s.a)(e,["components"]);return Object(i.b)(b,Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{className:"g-type-display-2"},Object(i.b)("a",Object(n.a)({parentName:"h1"},{className:"__permalink-h",href:"#consensus-protocol","aria-label":"consensus protocol permalink"}),"\xbb"),Object(i.b)("a",Object(n.a)({parentName:"h1"},{className:"__target-h",id:"consensus-protocol","aria-hidden":""})),"Consensus Protocol"),Object(i.b)("p",null,"Nomad uses a ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Consensus_(computer_science)"}),"consensus protocol"),"\nto provide ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/CAP_theorem"}),"Consistency (as defined by CAP)"),".\nThe consensus protocol is based on\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://raft.github.io/raft.pdf"}),'"Raft: In search of an Understandable Consensus Algorithm"'),".\nFor a visual explanation of Raft, see ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://thesecretlivesofdata.com/raft"}),"The Secret Lives of Data"),"."),Object(i.b)("div",{className:"alert alert-warning g-type-body",role:"alert"},Object(i.b)("p",{parentName:"div"},"",Object(i.b)("strong",{parentName:"p"},"Advanced Topic!")," This page covers technical details of\nthe internals of Nomad. You do not need to know these details to effectively\noperate and use Nomad. These details are documented here for those who wish\nto learn about them without having to go spelunking through the source code.")),Object(i.b)("h2",{className:"g-type-display-3"},Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__permalink-h",href:"#raft-protocol-overview","aria-label":"raft protocol overview permalink"}),"\xbb"),Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__target-h",id:"raft-protocol-overview","aria-hidden":""})),"Raft Protocol Overview"),Object(i.b)("p",null,"Raft is a consensus algorithm that is based on\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Paxos_%28computer_science%29"}),"Paxos"),". Compared\nto Paxos, Raft is designed to have fewer states and a simpler, more\nunderstandable algorithm."),Object(i.b)("p",null,"There are a few key terms to know when discussing Raft:"),Object(i.b)("ul",null,Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Log")," - The primary unit of work in a Raft system is a log entry. The problem\nof consistency can be decomposed into a ",Object(i.b)("em",{parentName:"p"},"replicated log"),". A log is an ordered\nsequence of entries. We consider the log consistent if all members agree on\nthe entries and their order.")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"FSM")," - ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Finite-state_machine"}),"Finite State Machine"),".\nAn FSM is a collection of finite states with transitions between them. As new logs\nare applied, the FSM is allowed to transition between states. Application of the\nsame sequence of logs must result in the same state, meaning behavior must be deterministic.")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Peer set")," - The peer set is the set of all members participating in log replication.\nFor Nomad's purposes, all server nodes are in the peer set of the local region.")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Quorum")," - A quorum is a majority of members from a peer set: for a set of size ",Object(i.b)("inlineCode",{parentName:"p"},"n"),",\nquorum requires at least ",Object(i.b)("inlineCode",{parentName:"p"},"\u230a(n/2)+1\u230b")," members.\nFor example, if there are 5 members in the peer set, we would need 3 nodes\nto form a quorum. If a quorum of nodes is unavailable for any reason, the\ncluster becomes ",Object(i.b)("em",{parentName:"p"},"unavailable")," and no new logs can be committed.")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Committed Entry")," - An entry is considered ",Object(i.b)("em",{parentName:"p"},"committed")," when it is durably stored\non a quorum of nodes. Once an entry is committed it can be applied.")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Leader")," - At any given time, the peer set elects a single node to be the leader.\nThe leader is responsible for ingesting new log entries, replicating to followers,\nand managing when an entry is considered committed."))),Object(i.b)("p",null,"Raft is a complex protocol and will not be covered here in detail (for those who\ndesire a more comprehensive treatment, the full specification is available in this\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://raft.github.io/raft.pdf"}),"paper"),").\nWe will, however, attempt to provide a high level description which may be useful\nfor building a mental model."),Object(i.b)("p",null,"Raft nodes are always in one of three states: follower, candidate, or leader. All\nnodes initially start out as a follower. In this state, nodes can accept log entries\nfrom a leader and cast votes. If no entries are received for some time, nodes\nself-promote to the candidate state. In the candidate state, nodes request votes from\ntheir peers. If a candidate receives a quorum of votes, then it is promoted to a leader.\nThe leader must accept new log entries and replicate to all the other followers.\nIn addition, if stale reads are not acceptable, all queries must also be performed on\nthe leader."),Object(i.b)("p",null,"Once a cluster has a leader, it is able to accept new log entries. A client can\nrequest that a leader append a new log entry (from Raft's perspective, a log entry\nis an opaque binary blob). The leader then writes the entry to durable storage and\nattempts to replicate to a quorum of followers. Once the log entry is considered\n",Object(i.b)("em",{parentName:"p"},"committed"),", it can be ",Object(i.b)("em",{parentName:"p"},"applied")," to a finite state machine. The finite state machine\nis application specific; in Nomad's case, we use\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/hashicorp/go-memdb"}),"MemDB")," to maintain cluster state."),Object(i.b)("p",null,"Obviously, it would be undesirable to allow a replicated log to grow in an unbounded\nfashion. Raft provides a mechanism by which the current state is snapshotted and the\nlog is compacted. Because of the FSM abstraction, restoring the state of the FSM must\nresult in the same state as a replay of old logs. This allows Raft to capture the FSM\nstate at a point in time and then remove all the logs that were used to reach that\nstate. This is performed automatically without user intervention and prevents unbounded\ndisk usage while also minimizing time spent replaying logs. One of the advantages of\nusing MemDB is that it allows Nomad to continue accepting new transactions even while\nold state is being snapshotted, preventing any availability issues."),Object(i.b)("p",null,"Consensus is fault-tolerant up to the point where quorum is available.\nIf a quorum of nodes is unavailable, it is impossible to process log entries or reason\nabout peer membership. For example, suppose there are only 2 peers: A and B. The quorum\nsize is also 2, meaning both nodes must agree to commit a log entry. If either A or B\nfails, it is now impossible to reach quorum. This means the cluster is unable to add\nor remove a node or to commit any additional log entries. This results in\n",Object(i.b)("em",{parentName:"p"},"unavailability"),". At this point, manual intervention would be required to remove\neither A or B and to restart the remaining node in bootstrap mode."),Object(i.b)("p",null,"A Raft cluster of 3 nodes can tolerate a single node failure while a cluster\nof 5 can tolerate 2 node failures. The recommended configuration is to either\nrun 3 or 5 Nomad servers per region. This maximizes availability without\ngreatly sacrificing performance. The ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#deployment_table"}),"deployment table")," below\nsummarizes the potential cluster size options and the fault tolerance of each."),Object(i.b)("p",null,"In terms of performance, Raft is comparable to Paxos. Assuming stable leadership,\ncommitting a log entry requires a single round trip to half of the cluster.\nThus, performance is bound by disk I/O and network latency."),Object(i.b)("h2",{className:"g-type-display-3"},Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__permalink-h",href:"#raft-in-nomad","aria-label":"raft in nomad permalink"}),"\xbb"),Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__target-h",id:"raft-in-nomad","aria-hidden":""})),"Raft in Nomad"),Object(i.b)("p",null,"Only Nomad server nodes participate in Raft and are part of the peer set. All\nclient nodes forward requests to servers. The clients in Nomad only need to know\nabout their allocations and query that information from the servers, while the\nservers need to maintain the global state of the cluster."),Object(i.b)("p",null,"Since all servers participate as part of the peer set, they all know the current\nleader. When an RPC request arrives at a non-leader server, the request is\nforwarded to the leader. If the RPC is a ",Object(i.b)("em",{parentName:"p"},"query")," type, meaning it is read-only,\nthe leader generates the result based on the current state of the FSM. If\nthe RPC is a ",Object(i.b)("em",{parentName:"p"},"transaction")," type, meaning it modifies state, the leader\ngenerates a new log entry and applies it using Raft. Once the log entry is committed\nand applied to the FSM, the transaction is complete."),Object(i.b)("p",null,"Because of the nature of Raft's replication, performance is sensitive to network\nlatency. For this reason, each region elects an independent leader and maintains\na disjoint peer set. Data is partitioned by region, so each leader is responsible\nonly for data in their region. When a request is received for a remote region,\nthe request is forwarded to the correct leader. This design allows for lower latency\ntransactions and higher availability without sacrificing consistency."),Object(i.b)("h2",{className:"g-type-display-3"},Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__permalink-h",href:"#consistency-modes","aria-label":"consistency modes permalink"}),"\xbb"),Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__target-h",id:"consistency-modes","aria-hidden":""})),"Consistency Modes"),Object(i.b)("p",null,"Although all writes to the replicated log go through Raft, reads are more\nflexible. To support various trade-offs that developers may want, Nomad\nsupports 2 different consistency modes for reads."),Object(i.b)("p",null,"The two read modes are:"),Object(i.b)("ul",null,Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("a",Object(n.a)({parentName:"li"},{id:"default",className:"__target-lic","aria-hidden":""})),Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#default","aria-label":"default permalink",className:"__permalink-lic"}),Object(i.b)("inlineCode",{parentName:"a"},"default"))," - Raft makes use of leader leasing, providing a time window\nin which the leader assumes its role is stable. However, if a leader\nis partitioned from the remaining peers, a new leader may be elected\nwhile the old leader is holding the lease. This means there are 2 leader\nnodes. There is no risk of a split-brain since the old leader will be\nunable to commit new logs. However, if the old leader services any reads,\nthe values are potentially stale. The default consistency mode relies only\non leader leasing, exposing clients to potentially stale values. We make\nthis trade-off because reads are fast, usually strongly consistent, and\nonly stale in a hard-to-trigger situation. The time window of stale reads\nis also bounded since the leader will step down due to the partition.")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(i.b)("a",Object(n.a)({parentName:"li"},{id:"stale",className:"__target-lic","aria-hidden":""})),Object(i.b)("p",{parentName:"li"},Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"#stale","aria-label":"stale permalink",className:"__permalink-lic"}),Object(i.b)("inlineCode",{parentName:"a"},"stale"))," - This mode allows any server to service the read regardless of if\nit is the leader. This means reads can be arbitrarily stale but are generally\nwithin 50 milliseconds of the leader. The trade-off is very fast and scalable\nreads but with stale values. This mode allows reads without a leader meaning\na cluster that is unavailable will still be able to respond."))),Object(i.b)("h2",{className:"g-type-display-3"},Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__permalink-h",href:"#deployment_table","aria-label":"deployment table permalink"}),"\xbb"),Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__target-h __compat",id:"deployment_table","aria-hidden":""})),Object(i.b)("a",Object(n.a)({parentName:"h2"},{className:"__target-h",id:"deployment-table","aria-hidden":""})),"Deployment Table"),Object(i.b)("p",null,"Below is a table that shows quorum size and failure tolerance for various\ncluster sizes. The recommended deployment is either 3 or 5 servers. A single\nserver deployment is ",Object(i.b)("em",{parentName:"p"},Object(i.b)("strong",{parentName:"em"},"highly"))," discouraged as data loss is inevitable in a\nfailure scenario."),Object(i.b)("table",null,Object(i.b)("thead",null,Object(i.b)("tr",null,Object(i.b)("th",null,"Servers"),Object(i.b)("th",null,"Quorum Size"),Object(i.b)("th",null,"Failure Tolerance"))),Object(i.b)("tbody",null,Object(i.b)("tr",null,Object(i.b)("td",null,"1"),Object(i.b)("td",null,"1"),Object(i.b)("td",null,"0")),Object(i.b)("tr",null,Object(i.b)("td",null,"2"),Object(i.b)("td",null,"2"),Object(i.b)("td",null,"0")),Object(i.b)("tr",{class:"warning"},Object(i.b)("td",null,"3"),Object(i.b)("td",null,"2"),Object(i.b)("td",null,"1")),Object(i.b)("tr",null,Object(i.b)("td",null,"4"),Object(i.b)("td",null,"3"),Object(i.b)("td",null,"1")),Object(i.b)("tr",{class:"warning"},Object(i.b)("td",null,"5"),Object(i.b)("td",null,"3"),Object(i.b)("td",null,"2")),Object(i.b)("tr",null,Object(i.b)("td",null,"6"),Object(i.b)("td",null,"4"),Object(i.b)("td",null,"2")),Object(i.b)("tr",null,Object(i.b)("td",null,"7"),Object(i.b)("td",null,"4"),Object(i.b)("td",null,"3")))))}d.isMDXComponent=!0}},[["URTX",0,1,2,4,3,5,6]]]);