(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{VNtm:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return h}));var a=n("wx14"),o=n("Ff2n"),s=n("q1tI"),i=n.n(s),l=n("7ljp"),c=n("j1un"),r=(i.a.createElement,{}),p=Object(c.a)({layout:"docs",page_title:"Storage Plugins",sidebar_title:"Storage",description:"Learn how Nomad manages dynamic storage plugins.",__resourcePath:"docs/internals/plugins/csi.mdx",__scans:{}});function h(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(l.b)(p,Object(a.a)({},r,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h1",{className:"g-type-display-2"},Object(l.b)("a",Object(a.a)({parentName:"h1"},{className:"__permalink-h",href:"#storage-plugins","aria-label":"storage plugins permalink"}),"\xbb"),Object(l.b)("a",Object(a.a)({parentName:"h1"},{className:"__target-h",id:"storage-plugins","aria-hidden":""})),"Storage Plugins"),Object(l.b)("p",null,"Nomad has built-in support for scheduling compute resources such as\nCPU, memory, and networking. Nomad's storage plugin support extends\nthis to allow scheduling tasks with externally created storage\nvolumes. Storage plugins are third-party plugins that conform to the\n",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/container-storage-interface/spec"}),"Container Storage Interface (CSI)")," specification."),Object(l.b)("p",null,"Storage plugins are created dynamically as Nomad jobs, unlike device\nand task driver plugins that need to be installed and configured on\neach client. Each dynamic plugin type has its own type-specific job\nspec block; currently there is only the ",Object(l.b)("inlineCode",{parentName:"p"},"csi_plugin")," type. Nomad\ntracks which clients have instances of a given plugin, and\ncommunicates with plugins over a Unix domain socket that it creates\ninside the plugin's tasks."),Object(l.b)("h2",{className:"g-type-display-3"},Object(l.b)("a",Object(a.a)({parentName:"h2"},{className:"__permalink-h",href:"#csi-plugins","aria-label":"csi plugins permalink"}),"\xbb"),Object(l.b)("a",Object(a.a)({parentName:"h2"},{className:"__target-h",id:"csi-plugins","aria-hidden":""})),"CSI Plugins"),Object(l.b)("p",null,"Every storage vendor has its own APIs and workflows, and the\nindustry-standard Container Storage Interface specification unifies\nthese APIs in a way that's agnostic to both the storage vendor and the\ncontainer orchestrator. Each storage provider can build its own CSI\nplugin. Jobs can claim storage volumes from AWS Elastic Block Storage\n(EBS) volumes, GCP persistent disks, Ceph, Portworx, vSphere, etc. The\nNomad scheduler will be aware of volumes created by CSI plugins and\nschedule workloads based on the availability of volumes on a given\nNomad client node. A list of available CSI plugins can be found in the\n",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://kubernetes-csi.github.io/docs/drivers.html"}),"Kubernetes CSI documentation"),". Any of these plugins\nshould work with Nomad out of the box."),Object(l.b)("p",null,"A CSI plugin task requires the ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/job-specification/csi_plugin"}),Object(l.b)("inlineCode",{parentName:"a"},"csi_plugin"))," block:"),Object(l.b)("pre",{className:"language-hcl"},Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-hcl"}),Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token keyword"}),"csi_plugin")," ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token punctuation"}),"{"),"\n  ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token property"}),"id"),"        ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token string"}),'"csi-hostpath"'),"\n  ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token property"}),"type"),"      ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token string"}),'"monolith"'),"\n  ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token property"}),"mount_dir")," ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token string"}),'"/csi"'),"\n",Object(l.b)("span",Object(a.a)({parentName:"code"},{className:"token punctuation"}),"}"),"\n")),Object(l.b)("p",null,"There are three ",Object(l.b)("strong",{parentName:"p"},"types")," of CSI plugins. ",Object(l.b)("strong",{parentName:"p"},"Controller Plugins"),'\ncommunicate with the storage provider\'s APIs. For example, for a job\nthat needs an AWS EBS volume, Nomad will tell the controller plugin\nthat it needs a volume to be "published" to the client node, and the\ncontroller will make the API calls to AWS to attach the EBS volume to\nthe right EC2 instance. ',Object(l.b)("strong",{parentName:"p"},"Node Plugins")," do the work on each client\nnode, like creating mount points. ",Object(l.b)("strong",{parentName:"p"},"Monolith Plugins")," are plugins\nthat perform both the controller and node roles in the same\ninstance. Not every plugin provider has or needs a controller; that's\nspecific to the provider implementation."),Object(l.b)("p",null,"You should always run node plugins as Nomad ",Object(l.b)("inlineCode",{parentName:"p"},"system")," jobs and use the\n",Object(l.b)("inlineCode",{parentName:"p"},"-ignore-system")," flag on the ",Object(l.b)("inlineCode",{parentName:"p"},"nomad node drain")," command to ensure that the\nnode plugins are still running while the node is being drained. Use\nconstraints for the node plugin jobs based on the availability of volumes. For\nexample, AWS EBS volumes are specific to particular availability zones with a\nregion. Controller plugins can be run as ",Object(l.b)("inlineCode",{parentName:"p"},"service")," jobs."),Object(l.b)("p",null,"Nomad exposes a Unix domain socket named ",Object(l.b)("inlineCode",{parentName:"p"},"csi.sock")," inside each CSI\nplugin task, and communicates over the gRPC protocol expected by the\nCSI specification. The ",Object(l.b)("inlineCode",{parentName:"p"},"mount_dir")," field tells Nomad where the plugin\nexpects to find the socket file."),Object(l.b)("h3",{className:"g-type-display-4"},Object(l.b)("a",Object(a.a)({parentName:"h3"},{className:"__permalink-h",href:"#plugin-lifecycle-and-state","aria-label":"plugin lifecycle and state permalink"}),"\xbb"),Object(l.b)("a",Object(a.a)({parentName:"h3"},{className:"__target-h",id:"plugin-lifecycle-and-state","aria-hidden":""})),"Plugin Lifecycle and State"),Object(l.b)("p",null,"CSI plugins report their health like other Nomad jobs. If the plugin\ncrashes or otherwise terminates, Nomad will launch it again using the\nsame ",Object(l.b)("inlineCode",{parentName:"p"},"restart")," and ",Object(l.b)("inlineCode",{parentName:"p"},"reschedule"),' logic used for other jobs. If plugins\nare unhealthy, Nomad will mark the volumes they manage as\n"unscheduable".'),Object(l.b)("p",null,"Storage plugins don't have any responsibility (or ability) to monitor\nthe state of tasks that claim their volumes. Nomad sends mount and\npublish requests to storage plugins when a task claims a volume, and\nunmount and unpublish requests when a task stops."),Object(l.b)("p",null,"The dynamic plugin registry persists state to the Nomad client so that\nit can restore volume managers for plugin jobs after client restarts\nwithout disrupting storage."),Object(l.b)("h3",{className:"g-type-display-4"},Object(l.b)("a",Object(a.a)({parentName:"h3"},{className:"__permalink-h",href:"#volume-lifecycle","aria-label":"volume lifecycle permalink"}),"\xbb"),Object(l.b)("a",Object(a.a)({parentName:"h3"},{className:"__target-h",id:"volume-lifecycle","aria-hidden":""})),"Volume Lifecycle"),Object(l.b)("p",null,"The Nomad scheduler decides whether a given client can run an\nallocation based on whether it has a node plugin present for the\nvolume. But before a task can use a volume the client needs to \"claim\"\nthe volume for the allocation. The client makes an RPC call to the\nserver and waits for a response; the allocation's tasks won't start\nuntil the volume has been claimed and is ready."),Object(l.b)("p",null,"If the volume's plugin requires a controller, the server will send an\nRPC to the Nomad client where that controller is running. The Nomad\nclient will forward this request over the controller plugin's gRPC\nsocket. The controller plugin will make the request volume available\nto the node that needs it."),Object(l.b)("p",null,"Once the controller is done (or if there's no controller required),\nthe server will increment the count of claims on the volume and return\nto the client. This count passes through Nomad's state store so that\nNomad has a consistent view of which volumes are available for\nscheduling."),Object(l.b)("p",null,"The client then makes RPC calls to the node plugin running on that\nclient, and the node plugin mounts the volume to a staging area in\nthe Nomad data directory. Nomad will bind-mount this staged directory\ninto each task that mounts the volume."),Object(l.b)("p",null,'This cycle is reversed when a task that claims a volume becomes terminal. The\nclient will send an "unpublish" RPC to the server, which will send "detach"\nRPCs to the node plugin.  The node plugin unmounts the bind-mount from the\nallocation and unmounts the volume from the plugin (if it\'s not in use by\nanother task). The server will then send "unpublish" RPCs to the controller\nplugin (if any), and decrement the claim count for the volume. At this point\nthe volume\u2019s claim capacity has been freed up for scheduling.'))}h.isMDXComponent=!0},cuzM:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/internals/plugins/csi",function(){return n("VNtm")}])}},[["cuzM",0,1,2,4,3,5,6]]]);