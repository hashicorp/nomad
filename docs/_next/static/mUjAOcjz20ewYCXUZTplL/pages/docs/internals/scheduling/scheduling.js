(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{"33Il":function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/internals/scheduling/scheduling",function(){return a("jKDl")}])},jKDl:function(e,n,a){"use strict";a.r(n),a.d(n,"default",(function(){return h}));var t=a("wx14"),i=a("Ff2n"),s=a("q1tI"),o=a.n(s),l=a("7ljp"),r=a("j1un"),d=(o.a.createElement,{}),c=Object(r.a)({layout:"docs",page_title:"Scheduling",sidebar_title:"Internals",description:"Learn about how scheduling works in Nomad.",__resourcePath:"docs/internals/scheduling/scheduling.mdx",__scans:{}});function h(e){var n=e.components,a=Object(i.a)(e,["components"]);return Object(l.b)(c,Object(t.a)({},d,a,{components:n,mdxType:"MDXLayout"}),Object(l.b)("h1",{className:"g-type-display-2"},Object(l.b)("a",Object(t.a)({parentName:"h1"},{className:"__permalink-h",href:"#scheduling-in-nomad","aria-label":"scheduling in nomad permalink"}),"\xbb"),Object(l.b)("a",Object(t.a)({parentName:"h1"},{className:"__target-h",id:"scheduling-in-nomad","aria-hidden":""})),"Scheduling in Nomad"),Object(l.b)("p",null,Object(l.b)("a",Object(t.a)({parentName:"p"},{href:"/img/nomad-data-model.png"}),Object(l.b)("img",Object(t.a)({parentName:"a"},{src:"/img/nomad-data-model.png",alt:"Nomad Data Model"})))),Object(l.b)("p",null,'There are four primary "nouns" in Nomad; jobs, nodes, allocations, and\nevaluations. Jobs are submitted by users and represent a ',Object(l.b)("em",{parentName:"p"},"desired state"),". A job\nis a declarative description of tasks to run which are bounded by constraints\nand require resources. Tasks can be scheduled on nodes in the cluster running\nthe Nomad client. The mapping of tasks in a job to clients is done using\nallocations. An allocation is used to declare that a set of tasks in a job\nshould be run on a particular node. Scheduling is the process of determining\nthe appropriate allocations and is done as part of an evaluation."),Object(l.b)("p",null,"An evaluation is created any time the external state, either desired or\nemergent, changes. The desired state is based on jobs, meaning the desired\nstate changes if a new job is submitted, an existing job is updated, or a job\nis deregistered. The emergent state is based on the client nodes, and so we\nmust handle the failure of any clients in the system. These events trigger the\ncreation of a new evaluation, as Nomad must ",Object(l.b)("em",{parentName:"p"},"evaluate")," the state of the world\nand reconcile it with the desired state."),Object(l.b)("p",null,"This diagram shows the flow of an evaluation through Nomad:"),Object(l.b)("p",null,Object(l.b)("a",Object(t.a)({parentName:"p"},{href:"/img/nomad-evaluation-flow.png"}),Object(l.b)("img",Object(t.a)({parentName:"a"},{src:"/img/nomad-evaluation-flow.png",alt:"Nomad Evaluation Flow"})))),Object(l.b)("p",null,"The lifecycle of an evaluation begins with an event causing the evaluation to\nbe created. Evaluations are created in the ",Object(l.b)("inlineCode",{parentName:"p"},"pending")," state and are enqueued\ninto the evaluation broker. There is a single evaluation broker which runs on\nthe leader server. The evaluation broker is used to manage the queue of pending\nevaluations, provide priority ordering, and ensure at least once delivery."),Object(l.b)("p",null,"Nomad servers run scheduling workers, defaulting to one per CPU core, which are\nused to process evaluations. The workers dequeue evaluations from the broker,\nand then invoke the appropriate scheduler as specified by the job. Nomad ships\nwith a ",Object(l.b)("inlineCode",{parentName:"p"},"service")," scheduler that optimizes for long-lived services, a ",Object(l.b)("inlineCode",{parentName:"p"},"batch"),"\nscheduler that is used for fast placement of batch jobs, a ",Object(l.b)("inlineCode",{parentName:"p"},"system")," scheduler\nthat is used to run jobs on every node, and a ",Object(l.b)("inlineCode",{parentName:"p"},"core")," scheduler which is used\nfor internal maintenance."),Object(l.b)("p",null,"Schedulers are responsible for processing an evaluation and generating an\nallocation ",Object(l.b)("em",{parentName:"p"},"plan"),". The plan is the set of allocations to evict, update, or\ncreate. The specific logic used to generate a plan may vary by scheduler, but\ngenerally the scheduler needs to first reconcile the desired state with the\nreal state to determine what must be done. New allocations need to be placed\nand existing allocations may need to be updated, migrated, or stopped."),Object(l.b)("p",null,"Placing allocations is split into two distinct phases, feasibility checking and\nranking. In the first phase the scheduler finds nodes that are feasible by\nfiltering unhealthy nodes, those missing necessary drivers, and those failing\nthe specified constraints."),Object(l.b)("p",null,"The second phase is ranking, where the scheduler scores feasible nodes to find\nthe best fit. Scoring is primarily based on bin packing, which is used to\noptimize the resource utilization and density of applications, but is also\naugmented by affinity and anti-affinity rules. Nomad automatically applies a job\nanti-affinity rule which discourages colocating multiple instances of a task\ngroup. The combination of this anti-affinity and bin packing optimizes for\ndensity while reducing the probability of correlated failures."),Object(l.b)("p",null,"Once the scheduler has ranked enough nodes, the highest ranking node is\nselected and added to the allocation plan."),Object(l.b)("p",null,"When planning is complete, the scheduler submits the plan to the leader which\nadds the plan to the plan queue. The plan queue manages pending plans, provides\npriority ordering, and allows Nomad to handle concurrency races. Multiple\nschedulers are running in parallel without locking or reservations, making\nNomad optimistically concurrent. As a result, schedulers might overlap work on\nthe same node and cause resource over-subscription. The plan queue allows the\nleader node to protect against this and do partial or complete rejections of a\nplan."),Object(l.b)("p",null,"As the leader processes plans, it creates allocations when there is no conflict\nand otherwise informs the scheduler of a failure in the plan result. The plan\nresult provides feedback to the scheduler, allowing it to terminate or explore\nalternate plans if the previous plan was partially or completely rejected."),Object(l.b)("p",null,"Once the scheduler has finished processing an evaluation, it updates the status\nof the evaluation and acknowledges delivery with the evaluation broker. This\ncompletes the lifecycle of an evaluation. Allocations that were created,\nmodified or deleted as a result will be picked up by client nodes and will\nbegin execution."))}h.isMDXComponent=!0}},[["33Il",0,1,2,4,3,5,6]]]);