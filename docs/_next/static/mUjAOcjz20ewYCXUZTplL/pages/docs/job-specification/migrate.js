(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{NiOK:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/job-specification/migrate",function(){return t("nlxi")}])},nlxi:function(e,a,t){"use strict";t.r(a),t.d(a,"default",(function(){return h}));var n,i=t("wx14"),c=t("Ff2n"),l=t("q1tI"),r=t.n(l),s=t("7ljp"),o=t("j1un"),b=(r.a.createElement,n="Placement",function(e){return console.warn("Component "+n+" was not imported, exported, or provided by MDXProvider as global scope"),Object(s.b)("div",e)}),p={},m=Object(o.a)({layout:"docs",page_title:"migrate Stanza - Job Specification",sidebar_title:"migrate",description:"The \"migrate\" stanza specifies the group's migrate strategy. The migrate\nstrategy is used to control the job's behavior when it is being migrated off\nof a draining node.",__resourcePath:"docs/job-specification/migrate.mdx",__scans:{}});function h(e){var a=e.components,t=Object(c.a)(e,["components"]);return Object(s.b)(m,Object(i.a)({},p,t,{components:a,mdxType:"MDXLayout"}),Object(s.b)("h1",{className:"g-type-display-2"},Object(s.b)("a",Object(i.a)({parentName:"h1"},{className:"__permalink-h",href:"#migrate-stanza","aria-label":"migrate stanza permalink"}),"\xbb"),Object(s.b)("a",Object(i.a)({parentName:"h1"},{className:"__target-h",id:"migrate-stanza","aria-hidden":""})),Object(s.b)("inlineCode",{parentName:"h1"},"migrate")," Stanza"),Object(s.b)(b,{groups:[["job","migrate"],["job","group","migrate"]],mdxType:"Placement"}),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"migrate")," stanza specifies the group's strategy for migrating off of\n",Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"/docs/commands/node/drain"}),"draining")," nodes. If omitted, a default migration strategy is applied.\nIf specified at the job level, the configuration will apply to all groups\nwithin the job. Only service jobs with a count greater than 1 support migrate\nstanzas."),Object(s.b)("pre",{className:"language-hcl"},Object(s.b)("code",Object(i.a)({parentName:"pre"},{className:"language-hcl"}),"job ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token string"}),'"docs"')," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"{"),"\n  ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token keyword"}),"migrate")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"{"),"\n    ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token property"}),"max_parallel"),"     ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token number"}),"1"),"\n    ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token property"}),"health_check"),"     ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token string"}),'"checks"'),"\n    ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token property"}),"min_healthy_time")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token string"}),'"10s"'),"\n    ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token property"}),"healthy_deadline")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"=")," ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token string"}),'"5m"'),"\n  ",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"}"),"\n",Object(s.b)("span",Object(i.a)({parentName:"code"},{className:"token punctuation"}),"}"),"\n")),Object(s.b)("p",null,"When one or more nodes are draining, only ",Object(s.b)("inlineCode",{parentName:"p"},"max_parallel")," allocations will be\nstopped at a time. Node draining will not continue until replacement\nallocations have been healthy for their ",Object(s.b)("inlineCode",{parentName:"p"},"min_healthy_time")," or\n",Object(s.b)("inlineCode",{parentName:"p"},"healthy_deadline")," is reached."),Object(s.b)("p",null,"Note that a node's drain ",Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"/docs/commands/node/drain#deadline"}),"deadline")," will override the ",Object(s.b)("inlineCode",{parentName:"p"},"migrate"),"\nstanza for allocations on that node. The ",Object(s.b)("inlineCode",{parentName:"p"},"migrate")," stanza is for job authors to\ndefine how their services should be migrated, while the node drain deadline is\nfor system operators to put hard limits on how long a drain may take."),Object(s.b)("p",null,"See the ",Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"https://learn.hashicorp.com/nomad/operating-nomad/node-draining"}),"Workload Migration Guide")," for details\non node draining."),Object(s.b)("h2",{className:"g-type-display-3"},Object(s.b)("a",Object(i.a)({parentName:"h2"},{className:"__permalink-h",href:"#migrate-parameters","aria-label":"migrate parameters permalink"}),"\xbb"),Object(s.b)("a",Object(i.a)({parentName:"h2"},{className:"__target-h",id:"migrate-parameters","aria-hidden":""})),Object(s.b)("inlineCode",{parentName:"h2"},"migrate")," Parameters"),Object(s.b)("ul",null,Object(s.b)("li",Object(i.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(s.b)("a",Object(i.a)({parentName:"li"},{id:"max_parallel",className:"__target-lic","aria-hidden":""})),Object(s.b)("p",{parentName:"li"},Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"#max_parallel","aria-label":"max_parallel permalink",className:"__permalink-lic"}),Object(s.b)("inlineCode",{parentName:"a"},"max_parallel"))," ",Object(s.b)("inlineCode",{parentName:"p"},"(int: 1)")," - Specifies the number of allocations that can be\nmigrated at the same time. This number must be less than the total\n",Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"/docs/job-specification/group#count"}),Object(s.b)("inlineCode",{parentName:"a"},"count"))," for the group as ",Object(s.b)("inlineCode",{parentName:"p"},"count - max_parallel")," will be left running\nduring migrations.")),Object(s.b)("li",Object(i.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(s.b)("a",Object(i.a)({parentName:"li"},{id:"health_check",className:"__target-lic","aria-hidden":""})),Object(s.b)("p",{parentName:"li"},Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"#health_check","aria-label":"health_check permalink",className:"__permalink-lic"}),Object(s.b)("inlineCode",{parentName:"a"},"health_check"))," ",Object(s.b)("inlineCode",{parentName:"p"},'(string: "checks")')," - Specifies the mechanism in which\nallocations health is determined. The potential values are:"),Object(s.b)("ul",{parentName:"li"},Object(s.b)("li",Object(i.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(s.b)("p",{parentName:"li"},'"checks" - Specifies that the allocation should be considered healthy when\nall of its tasks are running and their associated ',Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"/docs/job-specification/service#check-parameters"}),"checks"),' are\nhealthy, and unhealthy if any of the tasks fail or not all checks become\nhealthy. This is a superset of "task_states" mode.')),Object(s.b)("li",Object(i.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(s.b)("p",{parentName:"li"},'"task_states" - Specifies that the allocation should be considered healthy when\nall its tasks are running and unhealthy if tasks fail.')))),Object(s.b)("li",Object(i.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(s.b)("a",Object(i.a)({parentName:"li"},{id:"min_healthy_time",className:"__target-lic","aria-hidden":""})),Object(s.b)("p",{parentName:"li"},Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"#min_healthy_time","aria-label":"min_healthy_time permalink",className:"__permalink-lic"}),Object(s.b)("inlineCode",{parentName:"a"},"min_healthy_time"))," ",Object(s.b)("inlineCode",{parentName:"p"},'(string: "10s")'),' - Specifies the minimum time the\nallocation must be in the healthy state before it is marked as healthy and\nunblocks further allocations from being migrated. This is specified using a\nlabel suffix like "30s" or "15m".')),Object(s.b)("li",Object(i.a)({parentName:"ul"},{className:"g-type-long-body"}),Object(s.b)("a",Object(i.a)({parentName:"li"},{id:"healthy_deadline",className:"__target-lic","aria-hidden":""})),Object(s.b)("p",{parentName:"li"},Object(s.b)("a",Object(i.a)({parentName:"p"},{href:"#healthy_deadline","aria-label":"healthy_deadline permalink",className:"__permalink-lic"}),Object(s.b)("inlineCode",{parentName:"a"},"healthy_deadline"))," ",Object(s.b)("inlineCode",{parentName:"p"},'(string: "5m")'),' - Specifies the deadline in which the\nallocation must be marked as healthy after which the allocation is\nautomatically transitioned to unhealthy. This is specified using a label\nsuffix like "2m" or "1h".'))))}h.isMDXComponent=!0}},[["NiOK",0,1,2,4,3,5,6]]]);